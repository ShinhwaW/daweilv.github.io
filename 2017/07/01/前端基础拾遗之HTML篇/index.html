<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 前端基础拾遗之HTML篇 · David 的个人博客 ๛ก(ｰ̀ωｰ́ก)</title><meta name="description" content="前端基础拾遗之HTML篇 - David"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://dawei.lv/atom.xml" title="David 的个人博客 ๛ก(ｰ̀ωｰ́ก)"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/daweilv" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">前端基础拾遗之HTML篇</h1><div class="post-info">Jul 1, 2017</div><div class="post-content"><ol>
<li><p>DOCTYPE 作用<br>DTD（文档类型定义）是一组机器可读的规则，他定义 XML 或 HTML 的特定版本中允许有什么，不允许有什么。而 DOCTYPE 是用来描述使用哪个 DTD，保证网页以标准模式渲染，一个不含任何 DOCTYPE 的网页将会以 怪异(quirks) 模式渲染。HTML5 之前的 HTML 基于 SGML(Standard Generalized Markup Language, 标准通用标记语言)标准，需要 DTD 来保证在标准模式下渲染。HTML5 只需要 DOCTYPE 就可以保证在标准模式下渲染。</p>
</li>
<li><p>浏览器解析 HTML 方式<br>标准模式、怪异模式和部分怪异（近乎标准）模式。在标准模式中，浏览器根据规范显示页面；在混杂模式中，页面以一种比较宽松的向后兼容的方式显示。那些基于 Mozilla 的 Gecko 渲染引擎的，或者 Internet Explorer 8 在 strict mode 下，除了在处理表格的方式上有细微差异外，与标准模式相同。</p>
</li>
<li><p>行内元素与块级元素对比<br>内容上，<br>一般情况下，行内元素只能包含数据和其他行内元素。而块级元素可以包含行内元素和其他块级元素。这种结构上的包含继承区别可以使块级元素创建比行内元素更”大型“的结构。<br>格式上，<br>默认情况下，行内元素不会以新行开始，而块级元素会新起一行。</p>
</li>
<li><p>行内元素列表<br>一个行内元素只占据它对应标签的边框所包含的空间。<br>b, big, i, small, tt<br>abbr, acronym, cite, code, dfn, em, kbd, strong, samp, var<br>a, bdo, br, img, map, object, q, script, span, sub, sup<br>button, input, label, select, textarea</p>
</li>
<li><p>块级元素列表<br>块级元素占据其父元素（容器）的整个空间，因此创建了一个“块”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt; 联系方式信息</span><br><span class="line">&lt;article&gt; HTML5 文章内容</span><br><span class="line">&lt;aside&gt; HTML5 伴随内容</span><br><span class="line">&lt;audio&gt; HTML5 音频播放</span><br><span class="line">&lt;blockquote&gt; 块引用</span><br><span class="line">&lt;canvas&gt; HTML5 绘制图形</span><br><span class="line">&lt;dd&gt; 定义列表中定义条目描述</span><br><span class="line">&lt;div&gt; 文档分区</span><br><span class="line">&lt;dl&gt; 定义列表</span><br><span class="line">&lt;fieldset&gt; 表单元素分组</span><br><span class="line">&lt;figcaption&gt; HTML5 图文信息组标题</span><br><span class="line">&lt;figure&gt; HTML5 图文信息组</span><br><span class="line">&lt;footer&gt; HTML5 区段尾或页尾</span><br><span class="line">&lt;form&gt; 表单</span><br><span class="line">&lt;h1&gt; , &lt;h2&gt; , &lt;h3&gt; , &lt;h4&gt; , &lt;h5&gt; , &lt;h6&gt; 标题级别 1-6.</span><br><span class="line">&lt;header&gt; HTML5 区段头或页头</span><br><span class="line">&lt;hgroup&gt; HTML5 标题组</span><br><span class="line">&lt;hr&gt; 水平分割线</span><br><span class="line">&lt;noscript&gt; 不支持脚本或禁用脚本时显示的内容</span><br><span class="line">&lt;ol&gt; 有序列表</span><br><span class="line">&lt;output&gt; HTML5 表单输出</span><br><span class="line">&lt;p&gt; 行</span><br><span class="line">&lt;pre&gt; 预格式化文本</span><br><span class="line">&lt;section&gt; HTML5 一个页面区段</span><br><span class="line">&lt;table&gt; 表格</span><br><span class="line">&lt;tfoot&gt; 表脚注</span><br><span class="line">&lt;ul&gt; 无序列表</span><br><span class="line">&lt;video&gt; HTML5 视频</span><br></pre></td></tr></table></figure>
</li>
<li><p>常见的浏览器内核有哪些？<br>Trident：主要有 IE 浏览器以及多核浏览器<br>Gecko：主要有 Firefox 以及 Firefox 的衍生浏览器<br>WebKit：主要有 Chrome 与 Chrome 的衍生浏览器、Safari 以及多核浏览器<br>Presto：之前主要应用于 Opera，不过现在的 Opera 使用 WebKit 内核<br>EdgeHTML：Microsoft Edge，Trident 的一个分支，移除所有旧版 Internet Explorer 遗留下来的代码，并重写主要的代码以和其他现代浏览器的设计精神互通有无</p>
</li>
<li><p>HTML 语义化<br>在程序中, 语义指的是一段代码的含义 — 例如 “这个 HTML 的元素有什么作用，扮演了什么样的角色”。<br>对开发人员及团队，有利于增加代码可读性，减少差异化；<br>对搜索引擎，有助于爬虫抓取更多的有效信息，有利于确定上下文和各个关键字的权重，利于 SEO；<br>对浏览器，即使在 CSS 加载异常的情况下，也能提供一个基础的默认文档样式，方便屏幕阅读器以更有意义的方式渲染。</p>
</li>
<li><p>渲染原理<br><img src="webkit.png" alt="webkit.png"></p>
<ol>
<li>浏览器会将 HTML 解析成一个 <code>DOM Tree</code>，<code>DOM Tree</code>的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。</li>
<li>将 CSS 解析成 <code>CSS Rule Tree</code> 。</li>
<li>根据 <code>DOM Tree</code> 和 <code>CSS Rule Tree</code> 来构造 Rendering Tree。注意：Rendering Tree 渲染树并不等同于 DOM 树，因为一些像 Header 或 display:none 的东西就没必要放在渲染树中了。</li>
<li>有了 Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的 CSS 定义以及他们的从属关系。下一步操作称之为 layout，顾名思义就是计算出每个节点在屏幕中的位置。</li>
<li>再下一步就是绘制，即遍历 render 树，并使用 UI 后端层绘制每个节点。</li>
</ol>
<p>reflow（回流）：读取或设置位置、尺寸、计算样式等等，都有可能触发 reflow。</p>
<p>repaint（重绘）：改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画， 但是元素的几何尺寸没有变。</p>
<p><a href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a" target="_blank" rel="noopener">https://gist.github.com/paulirish/5d52fb081b3570c81e3a</a><br><a href="http://www.cnblogs.com/slly/p/6640761.html" target="_blank" rel="noopener">http://www.cnblogs.com/slly/p/6640761.html</a></p>
</li>
<li><p>HTTP 超文本传输协议（HyperText Transfer Protocol）</p>
</li>
<li><p>HTTP2<br>多路复用、二进制分帧、头部压缩、服务端推送。</p>
<p>HTTP/1.x 客户端需要使用多个连接才能实现并发和缩短延迟；HTTP/1.x 不会压缩请求和响应标头，从而导致不必要的网络流量；HTTP/1.x 不支持有效的资源优先级，致使底层 TCP 连接的利用率低下；等等。</p>
<p>HTTP/2 通过支持标头字段压缩和在同一连接上进行多个并发交换，让应用更有效地利用网络资源，减少感知的延迟时间。具体来说，它可以对同一连接上的请求和响应消息进行交错发送并为 HTTP 标头字段使用有效编码。 HTTP/2 还允许为请求设置优先级，让更重要的请求更快速地完成，从而进一步提升性能。出台的协议对网络更加友好，因为与 HTTP/1.x 相比，可以使用更少的 TCP 连接。</p>
<p>这意味着与其他流的竞争减小，并且连接的持续时间变长，这些特性反过来提高了可用网络容量的利用率。 最后，HTTP/2 还可以通过使用二进制消息分帧对消息进行更高效的处理。<br><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn</a></p>
<ul>
<li>所有通信都在一个 TCP 连接上完成，此连接可以承载任意数量的双向数据流。</li>
<li>每个数据流都有一个唯一的标识符和可选的优先级信息，用于承载双向消息。</li>
<li>每条消息都是一条逻辑 HTTP 消息（例如请求或响应），包含一个或多个帧。</li>
<li>帧是最小的通信单位，承载着特定类型的数据，例如 HTTP 标头、消息负载，等等。 来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。</li>
</ul>
</li>
<li><p>iframe 优缺点<br>优点：<br>样式隔离，内外样式不会冲突；低改动成本接入其他模块功能；无刷新文件上传；实现长连接，作为 Websocket 不支持浏览器的替代方案<br>缺点：<br>iframe 会阻塞主页面的 onload 事件；搜索引擎的检索程序无法解读这种页面，不利于 SEO；iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</p>
</li>
<li><p>Websocket 替代方案</p>
</li>
<li><p>DOM BOM 区别<br>DOM 全称是 Document Object Model，也就是文档对象模型，用来操作 HTML 中的元素。例如：<code>document.body</code>、<code>document.getElementById(&#39;someid&#39;)</code>、<code>document.title = &#39;Welcome&#39;</code>。</p>
<p>BOM 是 Browser Object Model，浏览器对象模型，用来控制浏览器的行为。例如，<code>location.href = &quot;http://www.xxxx.com&quot;</code>、<code>window.reload</code>。</p>
</li>
<li><p>DOM1/DOM2/DOM3 区别<br>DOM1 级主要定义了 HTML 和 XML 文档的底层结构。在 DOM1 中，DOM 由两个模块组成：DOM Core（DOM 核心）和 DOM HTML。其中，DOM Core 规定了基于 XML 的文档结构标准，通过这个标准简化了对文档中任意部分的访问和操作。DOM HTML 则在 DOM 核心的基础上加以扩展，添加了针对 HTML 的对象和方法，如：JavaScript 中的 Document 对象.</p>
<p>在 DOM1 的基础上 DOM2 引入了更多的交互能力，也支持了更高级的 XML 特性。DOM2 将 DOM 分为更多具有联系的模块。DOM2 级在原来 DOM 的基础上又扩充了鼠标、用户界面事件、范围、遍历等细分模块，而且通过对象接口增加了对 CSS 的支持。DOM1 级中的 DOM 核心模块也经过扩展开始支持 XML 命名空间。</p>
<p>DOM3 进一步扩展了 DOM，引入了以统一方式加载和保存文档的方法，它在 DOM Load And Save 这个模块中定义；同时新增了验证文档的方法，是在 DOM Validation 这个模块中定义的。</p>
</li>
<li><p>addEventListener、attachEvent、on 区别<br>attachEvent 是 IE8- 添加事件的方法，onclick 会覆盖掉之前绑定的事件，addEventListener 以事件数组的形式添加事件监听，不会覆盖掉之前的事件监听。<a href="https://stackoverflow.com/questions/2657182/correct-usage-of-addeventlistener-attachevent" target="_blank" rel="noopener">1</a>,<a href="https://stackoverflow.com/questions/30914727/what-is-the-difference-between-addeventlistener-and-attachevent" target="_blank" rel="noopener">2</a></p>
</li>
<li><p>浏览器前进/后退缓存（Backward/Forward Cache，BF Cache）<br>对整个 web 页面的一个浏览器会话进行了内存缓存，包括他们对 JavaScript 状态。在访问过的页面间后退和前进不需要页面加载同时保存 JavaScript 状态。这个特性，被称为 bfcache（“后退前进缓存”），使得页面导航（切换）非常快。这个状态缓存被保存直到用户关闭浏览器。<br>检测是否被缓存：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(</span><br><span class="line">  <span class="string">"pageshow"</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"event.persisted"</span> + event.persisted);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(</span><br><span class="line">  <span class="string">"pagehide"</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"event.persisted"</span> + event.persisted);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><a href="https://harttle.land/2017/03/12/backward-forward-cache.html" target="_blank" rel="noopener">https://harttle.land/2017/03/12/backward-forward-cache.html</a><br><a href="https://developer.mozilla.org/en-US/docs/Archive/Misc_top_level/Working_with_BFCache" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Archive/Misc_top_level/Working_with_BFCache</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Mozilla/Firefox/Releases/1.5/Using_Firefox_1.5_caching" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Mozilla/Firefox/Releases/1.5/Using_Firefox_1.5_caching</a></p>
</li>
<li><p>事件的传播机制 <a href="https://www.w3.org/TR/uievents/" target="_blank" rel="noopener">w3c</a><br><img src="eventflow.svg" alt="eventflow"><br>三个阶段：首先进入捕获阶段 <code>Window</code> -&gt;<code>Document</code>-&gt;<code>&lt;html&gt;</code>-&gt;<code>&lt;body&gt;</code>，直到达到目标元素，再进入冒泡阶段，从目标元素反向沿着捕获路径回到 <code>Window</code>。</p>
</li>
<li><p>parentNode 和 parentElement 的区别<br>在大部分情况下 <code>parentElement === parentNode</code>，只有在 parentNode 不是 html element 的时候，parentElement = null。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.parentNode; <span class="comment">// the &lt;html&gt; element</span></span><br><span class="line"><span class="built_in">document</span>.body.parentElement; <span class="comment">// the &lt;html&gt; element</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.documentElement.parentNode; <span class="comment">// the document node</span></span><br><span class="line"><span class="built_in">document</span>.documentElement.parentElement; <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>children(HTMLCollection) 和 childNodes(NodeList) 的区别<br>childNodes 比 children 多包含了几个 <code>text</code> 节点，children 只有 html element。<br>如下图，<code>children[0] === childNodes[1]</code>。<br><img src="./childNodes-vs-children.png" alt="childNodes-vs-children"></p>
</li>
<li><p>document.ready 实现</p>
</li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2017/07/01/前端基础拾遗之CSS篇/" class="prev">上一篇</a><a href="/2017/05/04/在-Terminal-中打开-Sublime/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'lnyx';
var disqus_identifier = '2017/07/01/前端基础拾遗之HTML篇/';
var disqus_title = '前端基础拾遗之HTML篇';
var disqus_url = 'http://dawei.lv/2017/07/01/前端基础拾遗之HTML篇/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//lnyx.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2018 <a href="https://github.com/daweilv" target="_blank" rel="noopener">David</a>. Hosted by <a href="https://pages.coding.me" target="_blank" rel="noopener">Coding Pages</a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-119593463-1",'auto');ga('send','pageview');</script></body></html>